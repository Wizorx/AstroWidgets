<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Linear Transformation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #191919;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #matrix-display {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="matrix-display"></div>

    <script>
        let scene, camera, renderer, controls;
        let vectors = [];
        let vectorHandles = [];
        let gridLines = [];
        let raycaster, mouse;
        let selectedHandle = null;
        let isDragging = false;
        
        const SNAP_THRESHOLD = 0.3;
        const HANDLE_SIZE = 0.1;
        const GRID_SIZE = 5;
        const GRID_DIVISIONS = 5;
        
        const vectorColors = [
            new THREE.Color(0xff6b6b),
            new THREE.Color(0x6b9bff),
            new THREE.Color(0x6bff6b)
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x191919);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 3, 4);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create initial vectors
            const initialVectors = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1)
            ];

            initialVectors.forEach((vec, i) => {
                createVector(vec, vectorColors[i], i);
            });

            createGrid();
            updateMatrix();

            // Event listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);

            // Simple camera controls
            let isRotating = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 2 || (e.button === 0 && !selectedHandle)) {
                    isRotating = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isRotating && !isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    const phi = deltaX * 0.01;
                    const theta = deltaY * 0.01;

                    const pos = camera.position;
                    const radius = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
                    
                    let currentPhi = Math.atan2(pos.x, pos.z);
                    let currentTheta = Math.acos(pos.y / radius);

                    currentPhi += phi;
                    currentTheta += theta;
                    currentTheta = Math.max(0.1, Math.min(Math.PI - 0.1, currentTheta));

                    camera.position.x = radius * Math.sin(currentTheta) * Math.sin(currentPhi);
                    camera.position.y = radius * Math.cos(currentTheta);
                    camera.position.z = radius * Math.sin(currentTheta) * Math.cos(currentPhi);
                    camera.lookAt(0, 0, 0);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isRotating = false;
            });

            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Touch event listeners
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
        }

        function createVector(direction, color, index) {
            const origin = new THREE.Vector3(0, 0, 0);
            const length = direction.length();
            const arrowHelper = new THREE.ArrowHelper(
                direction.clone().normalize(),
                origin,
                length,
                color.getHex(),
                0.2,
                0.15
            );
            scene.add(arrowHelper);
            vectors[index] = { arrow: arrowHelper, direction: direction.clone(), color: color };

            // Create handle at the tip
            const handleGeometry = new THREE.SphereGeometry(HANDLE_SIZE, 16, 16);
            const handleMaterial = new THREE.MeshBasicMaterial({ 
                color: color.getHex(),
                transparent: true,
                opacity: 0.6
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.copy(direction);
            handle.userData = { vectorIndex: index };
            scene.add(handle);
            vectorHandles[index] = handle;
        }

        function createGrid() {
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.5
            });

            const gridExtent = 2.5; // Grid extends from -2.5 to 2.5 in each direction
            const numLines = 11; // Number of lines in each direction (includes center)

            for (let i = 0; i < numLines; i++) {
                for (let j = 0; j < numLines; j++) {
                    const u = (i / (numLines - 1)) * 2 - 1; // -1 to 1
                    const v = (j / (numLines - 1)) * 2 - 1; // -1 to 1

                    // Lines parallel to x-axis
                    const geom1 = new THREE.BufferGeometry();
                    gridLines.push({ 
                        geometry: geom1,
                        line: new THREE.Line(geom1, lineMaterial),
                        u: u * gridExtent,
                        v: v * gridExtent,
                        type: 'x',
                        extent: gridExtent
                    });
                    scene.add(gridLines[gridLines.length - 1].line);

                    // Lines parallel to y-axis
                    const geom2 = new THREE.BufferGeometry();
                    gridLines.push({ 
                        geometry: geom2,
                        line: new THREE.Line(geom2, lineMaterial),
                        u: u * gridExtent,
                        v: v * gridExtent,
                        type: 'y',
                        extent: gridExtent
                    });
                    scene.add(gridLines[gridLines.length - 1].line);

                    // Lines parallel to z-axis
                    const geom3 = new THREE.BufferGeometry();
                    gridLines.push({ 
                        geometry: geom3,
                        line: new THREE.Line(geom3, lineMaterial),
                        u: u * gridExtent,
                        v: v * gridExtent,
                        type: 'z',
                        extent: gridExtent
                    });
                    scene.add(gridLines[gridLines.length - 1].line);
                }
            }

            updateGrid();
        }

        function updateGrid() {
            const v1 = vectors[0].direction;
            const v2 = vectors[1].direction;
            const v3 = vectors[2].direction;

            gridLines.forEach(gridLine => {
                const { u, v, type, extent } = gridLine;
                let start, end;

                if (type === 'x') {
                    start = new THREE.Vector3().addScaledVector(v2, u).addScaledVector(v3, v).addScaledVector(v1, -extent);
                    end = new THREE.Vector3().addScaledVector(v2, u).addScaledVector(v3, v).addScaledVector(v1, extent);
                } else if (type === 'y') {
                    start = new THREE.Vector3().addScaledVector(v1, u).addScaledVector(v3, v).addScaledVector(v2, -extent);
                    end = new THREE.Vector3().addScaledVector(v1, u).addScaledVector(v3, v).addScaledVector(v2, extent);
                } else {
                    start = new THREE.Vector3().addScaledVector(v1, u).addScaledVector(v2, v).addScaledVector(v3, -extent);
                    end = new THREE.Vector3().addScaledVector(v1, u).addScaledVector(v2, v).addScaledVector(v3, extent);
                }

                const positions = new Float32Array([
                    start.x, start.y, start.z,
                    end.x, end.y, end.z
                ]);
                gridLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            });
        }

        function updateVector(index) {
            const vec = vectors[index];
            const direction = vec.direction;
            const length = direction.length();
            
            if (length > 0.001) {
                vec.arrow.setDirection(direction.clone().normalize());
                vec.arrow.setLength(length, 0.2, 0.15);
            } else {
                vec.arrow.setLength(0.001, 0.001, 0.001);
            }
            
            vectorHandles[index].position.copy(direction);
        }

        function snapVector(position, currentIndex) {
            // Snap to origin
            if (position.length() < SNAP_THRESHOLD) {
                return new THREE.Vector3(0, 0, 0);
            }

            // Snap to other vectors' directions
            for (let i = 0; i < vectors.length; i++) {
                if (i !== currentIndex) {
                    const otherDir = vectors[i].direction.clone().normalize();
                    const projection = otherDir.multiplyScalar(position.dot(otherDir));
                    if (position.distanceTo(projection) < SNAP_THRESHOLD) {
                        return projection;
                    }
                }
            }

            // Snap to plane spanned by other two vectors
            const otherIndices = [0, 1, 2].filter(i => i !== currentIndex);
            const v1 = vectors[otherIndices[0]].direction;
            const v2 = vectors[otherIndices[1]].direction;
            
            if (v1.length() > 0.001 && v2.length() > 0.001) {
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                if (normal.length() > 0.001) {
                    const distToPlane = Math.abs(position.dot(normal));
                    if (distToPlane < SNAP_THRESHOLD) {
                        const planePoint = position.clone().sub(normal.multiplyScalar(position.dot(normal)));
                        return planePoint;
                    }
                }
            }

            return position;
        }

        function onMouseDown(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vectorHandles);

            if (intersects.length > 0) {
                selectedHandle = intersects[0].object;
                isDragging = true;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && selectedHandle) {
                raycaster.setFromCamera(mouse, camera);
                
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(cameraDir, selectedHandle.position);
                
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                
                if (intersectionPoint) {
                    const vectorIndex = selectedHandle.userData.vectorIndex;
                    const snappedPosition = snapVector(intersectionPoint, vectorIndex);
                    
                    vectors[vectorIndex].direction.copy(snappedPosition);
                    updateVector(vectorIndex);
                    updateGrid();
                    updateMatrix();
                }
            }
        }

        function onMouseUp() {
            selectedHandle = null;
            isDragging = false;
        }

        function onTouchStart(event) {
            event.preventDefault();
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(vectorHandles);

                if (intersects.length > 0) {
                    selectedHandle = intersects[0].object;
                    isDragging = true;
                } else {
                    // Start camera rotation
                    window.touchRotating = true;
                    window.previousTouchPosition = { x: touch.clientX, y: touch.clientY };
                }
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

                if (isDragging && selectedHandle) {
                    raycaster.setFromCamera(mouse, camera);
                    
                    const cameraDir = new THREE.Vector3();
                    camera.getWorldDirection(cameraDir);
                    
                    const plane = new THREE.Plane();
                    plane.setFromNormalAndCoplanarPoint(cameraDir, selectedHandle.position);
                    
                    const intersectionPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectionPoint);
                    
                    if (intersectionPoint) {
                        const vectorIndex = selectedHandle.userData.vectorIndex;
                        const snappedPosition = snapVector(intersectionPoint, vectorIndex);
                        
                        vectors[vectorIndex].direction.copy(snappedPosition);
                        updateVector(vectorIndex);
                        updateGrid();
                        updateMatrix();
                    }
                } else if (window.touchRotating) {
                    const deltaX = touch.clientX - window.previousTouchPosition.x;
                    const deltaY = touch.clientY - window.previousTouchPosition.y;

                    const phi = deltaX * 0.01;
                    const theta = deltaY * 0.01;

                    const pos = camera.position;
                    const radius = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
                    
                    let currentPhi = Math.atan2(pos.x, pos.z);
                    let currentTheta = Math.acos(pos.y / radius);

                    currentPhi += phi;
                    currentTheta += theta;
                    currentTheta = Math.max(0.1, Math.min(Math.PI - 0.1, currentTheta));

                    camera.position.x = radius * Math.sin(currentTheta) * Math.sin(currentPhi);
                    camera.position.y = radius * Math.cos(currentTheta);
                    camera.position.z = radius * Math.sin(currentTheta) * Math.cos(currentPhi);
                    camera.lookAt(0, 0, 0);

                    window.previousTouchPosition = { x: touch.clientX, y: touch.clientY };
                }
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            selectedHandle = null;
            isDragging = false;
            window.touchRotating = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMatrix() {
            const v1 = vectors[0].direction;
            const v2 = vectors[1].direction;
            const v3 = vectors[2].direction;

            const c1 = vectors[0].color.getStyle();
            const c2 = vectors[1].color.getStyle();
            const c3 = vectors[2].color.getStyle();

            const matrixHTML = `
                $$\\left[\\begin{array}{ccc}
                \\color{${c1}}{${v1.x.toFixed(2)}} & \\color{${c2}}{${v2.x.toFixed(2)}} & \\color{${c3}}{${v3.x.toFixed(2)}} \\\\
                \\color{${c1}}{${v1.y.toFixed(2)}} & \\color{${c2}}{${v2.y.toFixed(2)}} & \\color{${c3}}{${v3.y.toFixed(2)}} \\\\
                \\color{${c1}}{${v1.z.toFixed(2)}} & \\color{${c2}}{${v2.z.toFixed(2)}} & \\color{${c3}}{${v3.z.toFixed(2)}}
                \\end{array}\\right]$$
            `;

            document.getElementById('matrix-display').innerHTML = matrixHTML;
            
            if (window.MathJax) {
                MathJax.typesetPromise([document.getElementById('matrix-display')]).catch((err) => console.log(err));
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
