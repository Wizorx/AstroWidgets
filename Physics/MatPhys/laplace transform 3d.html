<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive 3D Laplace Transform - Analytic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #191919;
            position: fixed; 
            width: 100%;
            height: 100%;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100%; 
            position: relative;
            display: flex;
            touch-action: none; 
        }
        
        .viewport {
            position: relative;
            flex: 1;
            touch-action: none;
            overflow: hidden; 
        }

        @media (max-width: 768px) {
            #canvas-container {
                flex-direction: column;
            }
            #canvas-container > .viewport {
                min-height: 0;
            }
        }
        
        @media (min-width: 769px) {
            #canvas-container {
                flex-direction: row;
            }
            #canvas-container > .viewport {
                height: 100%; 
            }
        }
        
        .viewport canvas {
            touch-action: none;
            display: block; 
        }
        
        .viewport-label {
            position: absolute;
            color: white;
            font-size: 14px; 
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 6px 12px;
            border-radius: 4px;
            z-index: 5;
            pointer-events: none;
        }
        
        @media (min-width: 769px) {
            .viewport-label {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
            }
        }
        
        @media (max-width: 768px) {
            #laplace-viewport .viewport-label {
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
            }
            #s-plane-viewport .viewport-label {
                bottom: 8px; 
                left: 50%;
                transform: translateX(-50%);
            }
        }
        
        .divider {
            background-color: #444;
            z-index: 1;
        }
        
        @media (min-width: 769px) {
            .divider {
                width: 2px;
                height: 100%;
                flex-shrink: 0;
            }
        }
        
        @media (max-width: 768px) {
            .divider {
                width: 100%;
                height: 2px;
                flex-shrink: 0;
            }
        }
        
        @media (min-width: 769px) {
            #hud {
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 650px;
                max-width: calc(100vw - 40px);
                background-color: rgba(0, 0, 0, 0.8);
                padding: 12px;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                z-index: 10;
                transition: opacity 0.3s, transform 0.3s;
            }
            
            #hud.hidden {
                opacity: 0;
                transform: translateY(20px);
                pointer-events: none;
            }
        }
        
        @media (max-width: 768px) {
            #hud {
                display: none;
            }
        }
        
        #mobile-equation-container {
            display: none;
        }
        
        @media (max-width: 768px) {
            #mobile-equation-container {
                display: block;
                position: absolute;
                top: 5px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.85);
                padding: 4px 8px;
                border-radius: 4px;
                color: white;
                z-index: 20;
                pointer-events: none;
                max-width: calc(100vw - 80px);
                text-align: center;
                overflow: hidden; 
            }
            
            #mobile-equation {
                font-size: 11px;
                white-space: nowrap; 
            }
        }
        
        #mobile-bottom-controls {
            display: none;
        }
        
        @media (max-width: 768px) {
            #mobile-bottom-controls {
                display: flex;
                position: absolute;
                bottom: 10px;
                left: 10px;
                right: 10px;
                gap: 8px;
                z-index: 15;
                align-items: flex-end;
            }
            
            #hud-toggle-mobile {
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                white-space: nowrap;
                flex-shrink: 0;
            }
            
            #mobile-function-panel {
                flex: 1;
                background-color: rgba(0, 0, 0, 0.8);
                padding: 8px;
                border-radius: 4px;
                transition: opacity 0.3s, transform 0.3s;
            }
            
            #mobile-function-panel.hidden {
                opacity: 0;
                transform: translateY(10px);
                pointer-events: none;
            }
            
            #mobile-function-panel label {
                display: block;
                font-size: 11px;
                margin-bottom: 4px;
                color: white;
            }
            
            #function-select-mobile {
                width: 100%;
                padding: 6px;
                background-color: #1f2937;
                color: white;
                border: 1px solid #374151;
                border-radius: 4px;
                font-size: 12px;
                cursor: pointer;
            }
        }
        
        @media (min-width: 769px) {
            #mobile-equation-container,
            #mobile-bottom-controls {
                display: none;
            }
            
            #hud-toggle {
                position: absolute;
                bottom: 20px;
                left: 20px;
                background-color: rgba(0, 0, 0, 0.6);
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 4px;
                cursor: pointer;
                z-index: 10;
                font-size: 14px;
            }
            
            #hud-toggle:hover {
                background-color: rgba(0, 0, 0, 0.8);
            }
        }
        
        @media (max-width: 768px) {
            #hud-toggle {
                display: none;
            }
        }
        
        #equation-container {
            margin-bottom: 12px;
            text-align: center;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        #equation {
            color: white;
            font-size: 18px;
            white-space: nowrap; 
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }

        select {
            width: 100%;
            padding: 6px 8px;
            background-color: #1f2937;
            color: white;
            border: 1px solid #374151;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        select option {
            background-color: #1f2937;
            color: white;
        }

        input[type="number"] {
            padding: 4px 8px;
            background-color: #1f2937;
            color: white;
            border: 1px solid #374151;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .help-text {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="viewport" id="s-plane-viewport">
            <div class="viewport-label">Complex Frequency (s-plane)</div>
        </div>
        <div class="divider"></div>
        <div class="viewport" id="laplace-viewport">
            <div class="viewport-label">Laplace Transform</div>
        </div>
    </div>
    
    <div id="mobile-equation-container">
        <div id="mobile-equation"></div>
    </div>
    
    <div id="mobile-bottom-controls">
        <button id="hud-toggle-mobile">Toggle</button>
        <div id="mobile-function-panel">
            <label for="function-select-mobile">Function f(t):</label>
            <select id="function-select-mobile">
                <option value="exp">e^(-at) [a=1]</option>
                <option value="constant">1 (unit step)</option>
                <option value="t">t</option>
                <option value="t2">t²</option>
                <option value="sin" selected>sin(ωt) [ω=2π]</option>
                <option value="cos">cos(ωt) [ω=2π]</option>
                <option value="exp_sin">e^(-at)sin(ωt) [a=0.5, ω=2π]</option>
                <option value="exp_cos">e^(-at)cos(ωt) [a=0.5, ω=2π]</option>
            </select>
        </div>
    </div>
    
    <button id="hud-toggle">Toggle HUD</button>
    
    <div id="hud">
        <div id="equation-container">
            <div id="equation"></div>
        </div>
        
        <div class="control-group">
            <label for="function-select">Function f(t):</label>
            <select id="function-select">
                <option value="exp">e^(-at) [a=1]</option>
                <option value="constant">1 (unit step)</option>
                <option value="t">t</option>
                <option value="t2">t²</option>
                <option value="sin" selected>sin(ωt) [ω=2π]</option>
                <option value="cos">cos(ωt) [ω=2π]</option>
                <option value="exp_sin">e^(-at)sin(ωt) [a=0.5, ω=2π]</option>
                <option value="exp_cos">e^(-at)cos(ωt) [a=0.5, ω=2π]</option>
            </select>
        </div>
        
        <div class="help-text">
            Left: Drag to pan | Scroll/Pinch to zoom<br>
            Right: Drag to rotate | Scroll/Pinch to zoom
        </div>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let sceneSPlane, sceneLaplace, cameraSPlane, cameraLaplace, rendererSPlane, rendererLaplace;
        let sReal = 0;  // σ (real part of s)
        let sImag = 0;  // ω (imaginary part of s)
        let currentFunction = 'sin';
        let draggableDot = null;
        let isDraggingDot = false;
        let tMin = 0;
        let tMax = 40;
        let lastComputedResult = { real: 0, imag: 0, divergent: false };
        
        const controlsSPlane = {
            isDragging: false,
            previousMousePosition: { x: 0, y: 0 },
            panX: 0,
            panY: 0,
            zoom: 1,
            isPinching: false,
            previousPinchDistance: 0
        };
        
        const controlsLaplace = {
            isDragging: false,
            previousMousePosition: { x: 0, y: 0 },
            theta: -Math.PI / 0.75,
            phi: Math.PI / 3,
            zoom: 1,
            isPinching: false,
            previousPinchDistance: 0
        };

        // Laplace transform pairs from tables
        const laplacePairs = {
            exp: {
                name: 'e^{-at}',
                params: { a: 1 },
                poles: (params) => [{ real: -params.a, imag: 0 }], // Pole at s = -a
                timeFunc: (t, params) => Math.exp(-params.a * t),
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const denom = (sr + params.a) * (sr + params.a) + si * si;
                    return {
                        real: (sr + params.a) / denom,
                        imag: -si / denom
                    };
                },
                // Windowed transform: integral from tMin to tMax of e^(-at) * e^(-st) dt
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const a = params.a;
                    
                    // e^(-(a+s)t) evaluated from tMin to tMax
                    const alpha_r = sr + a;
                    const alpha_i = si;
                    const alpha_mag_sq = alpha_r * alpha_r + alpha_i * alpha_i;
                    
                    if (alpha_mag_sq < 1e-15) {
                        // If a+s ≈ 0, integral is just (tMax - tMin)
                        return { real: tMax - tMin, imag: 0 };
                    }
                    
                    // exp(-(a+s)*tMax) - exp(-(a+s)*tMin)
                    const exp_max_r = Math.exp(-alpha_r * tMax) * Math.cos(-alpha_i * tMax);
                    const exp_max_i = Math.exp(-alpha_r * tMax) * Math.sin(-alpha_i * tMax);
                    const exp_min_r = Math.exp(-alpha_r * tMin) * Math.cos(-alpha_i * tMin);
                    const exp_min_i = Math.exp(-alpha_r * tMin) * Math.sin(-alpha_i * tMin);
                    
                    const diff_r = exp_max_r - exp_min_r;
                    const diff_i = exp_max_i - exp_min_i;
                    
                    // Divide by -(a+s)
                    return {
                        real: -(diff_r * alpha_r + diff_i * alpha_i) / alpha_mag_sq,
                        imag: -(diff_i * alpha_r - diff_r * alpha_i) / alpha_mag_sq
                    };
                },
                latex: (params) => `\\frac{1}{s + a}`
            },
            constant: {
                name: '1',
                params: {},
                poles: (params) => [{ real: 0, imag: 0 }], // Pole at s = 0
                timeFunc: (t, params) => 1,
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const denom = sr * sr + si * si;
                    if (denom < 1e-15) {
                        return { real: NaN, imag: NaN, divergent: true };
                    }
                    return {
                        real: sr / denom,
                        imag: -si / denom
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const s_mag_sq = sr * sr + si * si;
                    
                    if (s_mag_sq < 1e-15) {
                        return { real: tMax - tMin, imag: 0 };
                    }
                    
                    const exp_max_r = Math.exp(-sr * tMax) * Math.cos(-si * tMax);
                    const exp_max_i = Math.exp(-sr * tMax) * Math.sin(-si * tMax);
                    const exp_min_r = Math.exp(-sr * tMin) * Math.cos(-si * tMin);
                    const exp_min_i = Math.exp(-sr * tMin) * Math.sin(-si * tMin);
                    
                    const diff_r = exp_max_r - exp_min_r;
                    const diff_i = exp_max_i - exp_min_i;
                    
                    return {
                        real: -(diff_r * sr + diff_i * si) / s_mag_sq,
                        imag: -(diff_i * sr - diff_r * si) / s_mag_sq
                    };
                },
                latex: (params) => `\\frac{1}{s}`
            },
            t: {
                name: 't',
                params: {},
                poles: (params) => [{ real: 0, imag: 0 }], // Pole at s = 0 (double pole)
                timeFunc: (t, params) => t,
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const denom = (sr * sr + si * si) * (sr * sr + si * si);
                    if (denom < 1e-15) {
                        return { real: NaN, imag: NaN, divergent: true };
                    }
                    return {
                        real: (sr * sr - si * si) / denom,
                        imag: -2 * sr * si / denom
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const s_mag_sq = sr * sr + si * si;
                    
                    if (s_mag_sq < 1e-15) {
                        return { real: (tMax * tMax - tMin * tMin) / 2, imag: 0 };
                    }
                    
                    // Integral of t * e^(-st) from tMin to tMax
                    // = [-t*e^(-st)/s - e^(-st)/s^2] from tMin to tMax
                    
                    const eval_at_t = (t) => {
                        const exp_r = Math.exp(-sr * t) * Math.cos(-si * t);
                        const exp_i = Math.exp(-sr * t) * Math.sin(-si * t);
                        
                        // -t * e^(-st) / s
                        const term1_r = -t * (exp_r * sr + exp_i * si) / s_mag_sq;
                        const term1_i = -t * (exp_i * sr - exp_r * si) / s_mag_sq;
                        
                        // -e^(-st) / s^2
                        const s2_mag_sq = s_mag_sq * s_mag_sq;
                        const s2_r = sr * sr - si * si;
                        const s2_i = 2 * sr * si;
                        const term2_r = -(exp_r * s2_r + exp_i * s2_i) / s2_mag_sq;
                        const term2_i = -(exp_i * s2_r - exp_r * s2_i) / s2_mag_sq;
                        
                        return { r: term1_r + term2_r, i: term1_i + term2_i };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    return {
                        real: at_max.r - at_min.r,
                        imag: at_max.i - at_min.i
                    };
                },
                latex: (params) => `\\frac{1}{s^2}`
            },
            t2: {
                name: 't^2',
                params: {},
                poles: (params) => [{ real: 0, imag: 0 }], // Pole at s = 0 (triple pole)
                timeFunc: (t, params) => t * t,
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const s2 = sr * sr + si * si;
                    if (s2 < 1e-10) {
                        const angle = Math.atan2(si, sr);
                        const largeMag = 1e6;
                        return { 
                            real: largeMag * Math.cos(-3 * angle), 
                            imag: largeMag * Math.sin(-3 * angle),
                            divergent: false
                        };
                    }
                    const denom = s2 * s2 * s2;
                    const numerReal = 2 * sr * (sr * sr - 3 * si * si);
                    const numerImag = -2 * si * (3 * sr * sr - si * si);
                    return {
                        real: numerReal / denom,
                        imag: numerImag / denom,
                        divergent: false
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const s_mag_sq = sr * sr + si * si;
                    
                    if (s_mag_sq < 1e-15) {
                        return { real: (tMax * tMax * tMax - tMin * tMin * tMin) / 3, imag: 0 };
                    }
                    
                    // Integral of t^2 * e^(-st) from tMin to tMax using integration by parts twice
                    const eval_at_t = (t) => {
                        const exp_r = Math.exp(-sr * t) * Math.cos(-si * t);
                        const exp_i = Math.exp(-sr * t) * Math.sin(-si * t);
                        
                        const t2 = t * t;
                        const s2_mag_sq = s_mag_sq * s_mag_sq;
                        const s3_mag_sq = s2_mag_sq * s_mag_sq;
                        
                        // Complex division helpers
                        const div_s = (num_r, num_i) => ({
                            r: (num_r * sr + num_i * si) / s_mag_sq,
                            i: (num_i * sr - num_r * si) / s_mag_sq
                        });
                        
                        const s2_r = sr * sr - si * si;
                        const s2_i = 2 * sr * si;
                        const div_s2 = (num_r, num_i) => ({
                            r: (num_r * s2_r + num_i * s2_i) / s2_mag_sq,
                            i: (num_i * s2_r - num_r * s2_i) / s2_mag_sq
                        });
                        
                        const s3_r = sr * s2_r - si * s2_i;
                        const s3_i = sr * s2_i + si * s2_r;
                        const div_s3 = (num_r, num_i) => ({
                            r: (num_r * s3_r + num_i * s3_i) / s3_mag_sq,
                            i: (num_i * s3_r - num_r * s3_i) / s3_mag_sq
                        });
                        
                        // -t^2 * e^(-st) / s
                        const term1 = div_s(-t2 * exp_r, -t2 * exp_i);
                        
                        // -2t * e^(-st) / s^2
                        const term2 = div_s2(-2 * t * exp_r, -2 * t * exp_i);
                        
                        // -2 * e^(-st) / s^3
                        const term3 = div_s3(-2 * exp_r, -2 * exp_i);
                        
                        return {
                            r: term1.r + term2.r + term3.r,
                            i: term1.i + term2.i + term3.i
                        };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    return {
                        real: at_max.r - at_min.r,
                        imag: at_max.i - at_min.i
                    };
                },
                latex: (params) => `\\frac{2}{s^3}`
            },
            sin: {
                name: '\\sin(\\omega t)',
                params: { omega: 2 * Math.PI },
                poles: (params) => [
                    { real: 0, imag: params.omega },   // Pole at s = +iω
                    { real: 0, imag: -params.omega }   // Pole at s = -iω
                ],
                timeFunc: (t, params) => Math.sin(params.omega * t),
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const w = params.omega;
                    
                    // L{sin(wt)} = w/(s^2 + w^2)
                    // s^2 = (sr + i*si)^2 = sr^2 - si^2 + 2i*sr*si
                    const s2_r = sr * sr - si * si;
                    const s2_i = 2 * sr * si;
                    
                    // s^2 + w^2
                    const denom_r = s2_r + w * w;
                    const denom_i = s2_i;
                    
                    const denom_mag_sq = denom_r * denom_r + denom_i * denom_i;
                    
                    // w / (s^2 + w^2) = w * (denom_r - i*denom_i) / |denom|^2
                    return {
                        real: w * denom_r / denom_mag_sq,
                        imag: -w * denom_i / denom_mag_sq
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const w = params.omega;
                    
                    // Integral of sin(wt) * e^(-st) dt from tMin to tMax
                    // = [e^(-st) * (-s*sin(wt) - w*cos(wt))] / (s^2 + w^2) evaluated at bounds
                    
                    const eval_at_t = (t) => {
                        // e^(-st)
                        const exp_r = Math.exp(-sr * t) * Math.cos(-si * t);
                        const exp_i = Math.exp(-sr * t) * Math.sin(-si * t);
                        
                        const cos_wt = Math.cos(w * t);
                        const sin_wt = Math.sin(w * t);
                        
                        // -s * sin(wt) = (-sr - i*si) * sin(wt)
                        const term1_r = -sr * sin_wt;
                        const term1_i = -si * sin_wt;
                        
                        // -w * cos(wt) = -w * cos(wt) + 0i
                        const term2_r = -w * cos_wt;
                        const term2_i = 0;
                        
                        // Sum: (-s*sin(wt) - w*cos(wt))
                        const sum_r = term1_r + term2_r;
                        const sum_i = term1_i + term2_i;
                        
                        // Multiply: e^(-st) * sum
                        const prod_r = exp_r * sum_r - exp_i * sum_i;
                        const prod_i = exp_r * sum_i + exp_i * sum_r;
                        
                        return { r: prod_r, i: prod_i };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    // Difference
                    const diff_r = at_max.r - at_min.r;
                    const diff_i = at_max.i - at_min.i;
                    
                    // Divide by (s^2 + w^2)
                    const s2_r = sr * sr - si * si;
                    const s2_i = 2 * sr * si;
                    const s2_plus_w2_r = s2_r + w * w;
                    const s2_plus_w2_i = s2_i;
                    
                    const divisor_mag_sq = s2_plus_w2_r * s2_plus_w2_r + s2_plus_w2_i * s2_plus_w2_i;
                    
                    return {
                        real: (diff_r * s2_plus_w2_r + diff_i * s2_plus_w2_i) / divisor_mag_sq,
                        imag: (diff_i * s2_plus_w2_r - diff_r * s2_plus_w2_i) / divisor_mag_sq
                    };
                },
                latex: (params) => `\\frac{\\omega}{s^2 + \\omega^2}`
            },
            cos: {
                name: '\\cos(\\omega t)',
                params: { omega: 2 * Math.PI },
                poles: (params) => [
                    { real: 0, imag: params.omega },   // Pole at s = +iω
                    { real: 0, imag: -params.omega }   // Pole at s = -iω
                ],
                timeFunc: (t, params) => Math.cos(params.omega * t),
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const w = params.omega;
                    
                    // L{cos(wt)} = s/(s^2 + w^2)
                    // s^2 = (sr + i*si)^2 = sr^2 - si^2 + 2i*sr*si
                    const s2_r = sr * sr - si * si;
                    const s2_i = 2 * sr * si;
                    
                    // s^2 + w^2
                    const denom_r = s2_r + w * w;
                    const denom_i = s2_i;
                    
                    const denom_mag_sq = denom_r * denom_r + denom_i * denom_i;
                    
                    // s / (s^2 + w^2) = (sr + i*si) * (denom_r - i*denom_i) / |denom|^2
                    const numer_r = sr * denom_r + si * denom_i;
                    const numer_i = si * denom_r - sr * denom_i;
                    
                    return {
                        real: numer_r / denom_mag_sq,
                        imag: numer_i / denom_mag_sq
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const w = params.omega;
                    
                    // Integral of cos(wt) * e^(-st) dt from tMin to tMax
                    // = [e^(-st) * (-s*cos(wt) + w*sin(wt))] / (s^2 + w^2) evaluated at bounds
                    
                    const s_mag_sq = sr * sr + si * si;
                    const denom = s_mag_sq + w * w;
                    
                    const eval_at_t = (t) => {
                        // e^(-st)
                        const exp_r = Math.exp(-sr * t) * Math.cos(-si * t);
                        const exp_i = Math.exp(-sr * t) * Math.sin(-si * t);
                        
                        const cos_wt = Math.cos(w * t);
                        const sin_wt = Math.sin(w * t);
                        
                        // -s * cos(wt) = (-sr - i*si) * cos(wt)
                        const term1_r = -sr * cos_wt;
                        const term1_i = -si * cos_wt;
                        
                        // w * sin(wt) = w * sin(wt) + 0i
                        const term2_r = w * sin_wt;
                        const term2_i = 0;
                        
                        // Sum: (-s*cos(wt) + w*sin(wt))
                        const sum_r = term1_r + term2_r;
                        const sum_i = term1_i + term2_i;
                        
                        // Multiply: e^(-st) * sum
                        const prod_r = exp_r * sum_r - exp_i * sum_i;
                        const prod_i = exp_r * sum_i + exp_i * sum_r;
                        
                        return { r: prod_r, i: prod_i };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    // Difference
                    const diff_r = at_max.r - at_min.r;
                    const diff_i = at_max.i - at_min.i;
                    
                    // Divide by (s^2 + w^2)
                    // For complex s: s^2 = (sr + i*si)^2 = sr^2 - si^2 + 2i*sr*si
                    const s2_r = sr * sr - si * si;
                    const s2_i = 2 * sr * si;
                    const s2_plus_w2_r = s2_r + w * w;
                    const s2_plus_w2_i = s2_i;
                    
                    const divisor_mag_sq = s2_plus_w2_r * s2_plus_w2_r + s2_plus_w2_i * s2_plus_w2_i;
                    
                    return {
                        real: (diff_r * s2_plus_w2_r + diff_i * s2_plus_w2_i) / divisor_mag_sq,
                        imag: (diff_i * s2_plus_w2_r - diff_r * s2_plus_w2_i) / divisor_mag_sq
                    };
                },
                latex: (params) => `\\frac{s}{s^2 + \\omega^2}`
            },
            exp_sin: {
                name: 'e^{-at}\\sin(\\omega t)',
                params: { a: 0.5, omega: 2 * Math.PI },
                poles: (params) => [
                    { real: -params.a, imag: params.omega },   // Pole at s = -a + iω
                    { real: -params.a, imag: -params.omega }   // Pole at s = -a - iω
                ],
                timeFunc: (t, params) => Math.exp(-params.a * t) * Math.sin(params.omega * t),
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const a = params.a;
                    const w = params.omega;
                    
                    // L{e^(-at)sin(wt)} = w/((s+a)^2 + w^2)
                    // s+a = (sr+a) + i*si
                    const s_eff_r = sr + a;
                    const s_eff_i = si;
                    
                    // (s+a)^2
                    const s2_r = s_eff_r * s_eff_r - s_eff_i * s_eff_i;
                    const s2_i = 2 * s_eff_r * s_eff_i;
                    
                    // (s+a)^2 + w^2
                    const denom_r = s2_r + w * w;
                    const denom_i = s2_i;
                    
                    const denom_mag_sq = denom_r * denom_r + denom_i * denom_i;
                    
                    return {
                        real: w * denom_r / denom_mag_sq,
                        imag: -w * denom_i / denom_mag_sq
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const a = params.a;
                    const w = params.omega;
                    
                    // Integral of e^(-at) * sin(wt) * e^(-st) = integral of sin(wt) * e^(-(a+s)t)
                    // This is the same as sin integral but with s replaced by (s+a)
                    const s_eff_r = sr + a;
                    const s_eff_i = si;
                    
                    const eval_at_t = (t) => {
                        // e^(-(s+a)t)
                        const exp_r = Math.exp(-s_eff_r * t) * Math.cos(-s_eff_i * t);
                        const exp_i = Math.exp(-s_eff_r * t) * Math.sin(-s_eff_i * t);
                        
                        const cos_wt = Math.cos(w * t);
                        const sin_wt = Math.sin(w * t);
                        
                        // -(s+a) * sin(wt)
                        const term1_r = -s_eff_r * sin_wt;
                        const term1_i = -s_eff_i * sin_wt;
                        
                        // -w * cos(wt)
                        const term2_r = -w * cos_wt;
                        const term2_i = 0;
                        
                        const sum_r = term1_r + term2_r;
                        const sum_i = term1_i + term2_i;
                        
                        const prod_r = exp_r * sum_r - exp_i * sum_i;
                        const prod_i = exp_r * sum_i + exp_i * sum_r;
                        
                        return { r: prod_r, i: prod_i };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    const diff_r = at_max.r - at_min.r;
                    const diff_i = at_max.i - at_min.i;
                    
                    // Divide by ((s+a)^2 + w^2)
                    const s2_r = s_eff_r * s_eff_r - s_eff_i * s_eff_i;
                    const s2_i = 2 * s_eff_r * s_eff_i;
                    const s2_plus_w2_r = s2_r + w * w;
                    const s2_plus_w2_i = s2_i;
                    
                    const divisor_mag_sq = s2_plus_w2_r * s2_plus_w2_r + s2_plus_w2_i * s2_plus_w2_i;
                    
                    return {
                        real: (diff_r * s2_plus_w2_r + diff_i * s2_plus_w2_i) / divisor_mag_sq,
                        imag: (diff_i * s2_plus_w2_r - diff_r * s2_plus_w2_i) / divisor_mag_sq
                    };
                },
                latex: (params) => `\\frac{\\omega}{(s + a)^2 + \\omega^2}`
            },
            exp_cos: {
                name: 'e^{-at}\\cos(\\omega t)',
                params: { a: 0.5, omega: 2 * Math.PI },
                poles: (params) => [
                    { real: -params.a, imag: params.omega },   // Pole at s = -a + iω
                    { real: -params.a, imag: -params.omega }   // Pole at s = -a - iω
                ],
                timeFunc: (t, params) => Math.exp(-params.a * t) * Math.cos(params.omega * t),
                transform: (s, params) => {
                    const sr = s.real;
                    const si = s.imag;
                    const a = params.a;
                    const w = params.omega;
                    
                    // L{e^(-at)cos(wt)} = (s+a)/((s+a)^2 + w^2)
                    // s+a = (sr+a) + i*si
                    const s_eff_r = sr + a;
                    const s_eff_i = si;
                    
                    // (s+a)^2
                    const s2_r = s_eff_r * s_eff_r - s_eff_i * s_eff_i;
                    const s2_i = 2 * s_eff_r * s_eff_i;
                    
                    // (s+a)^2 + w^2
                    const denom_r = s2_r + w * w;
                    const denom_i = s2_i;
                    
                    const denom_mag_sq = denom_r * denom_r + denom_i * denom_i;
                    
                    // (s+a) / ((s+a)^2 + w^2)
                    const numer_r = s_eff_r * denom_r + s_eff_i * denom_i;
                    const numer_i = s_eff_i * denom_r - s_eff_r * denom_i;
                    
                    return {
                        real: numer_r / denom_mag_sq,
                        imag: numer_i / denom_mag_sq
                    };
                },
                windowedTransform: (s, params, tMin, tMax) => {
                    const sr = s.real;
                    const si = s.imag;
                    const a = params.a;
                    const w = params.omega;
                    
                    // Same as cos integral but with s replaced by (s+a)
                    const s_eff_r = sr + a;
                    const s_eff_i = si;
                    
                    const eval_at_t = (t) => {
                        // e^(-(s+a)t)
                        const exp_r = Math.exp(-s_eff_r * t) * Math.cos(-s_eff_i * t);
                        const exp_i = Math.exp(-s_eff_r * t) * Math.sin(-s_eff_i * t);
                        
                        const cos_wt = Math.cos(w * t);
                        const sin_wt = Math.sin(w * t);
                        
                        // -(s+a) * cos(wt)
                        const term1_r = -s_eff_r * cos_wt;
                        const term1_i = -s_eff_i * cos_wt;
                        
                        // w * sin(wt)
                        const term2_r = w * sin_wt;
                        const term2_i = 0;
                        
                        const sum_r = term1_r + term2_r;
                        const sum_i = term1_i + term2_i;
                        
                        const prod_r = exp_r * sum_r - exp_i * sum_i;
                        const prod_i = exp_r * sum_i + exp_i * sum_r;
                        
                        return { r: prod_r, i: prod_i };
                    };
                    
                    const at_max = eval_at_t(tMax);
                    const at_min = eval_at_t(tMin);
                    
                    const diff_r = at_max.r - at_min.r;
                    const diff_i = at_max.i - at_min.i;
                    
                    // Divide by ((s+a)^2 + w^2)
                    const s2_r = s_eff_r * s_eff_r - s_eff_i * s_eff_i;
                    const s2_i = 2 * s_eff_r * s_eff_i;
                    const s2_plus_w2_r = s2_r + w * w;
                    const s2_plus_w2_i = s2_i;
                    
                    const divisor_mag_sq = s2_plus_w2_r * s2_plus_w2_r + s2_plus_w2_i * s2_plus_w2_i;
                    
                    return {
                        real: (diff_r * s2_plus_w2_r + diff_i * s2_plus_w2_i) / divisor_mag_sq,
                        imag: (diff_i * s2_plus_w2_r - diff_r * s2_plus_w2_i) / divisor_mag_sq
                    };
                },
                latex: (params) => `\\frac{s + a}{(s + a)^2 + \\omega^2}`
            }
        };

        function evaluateTransform(sr, si) {
            const pair = laplacePairs[currentFunction];
            const result = pair.transform({ real: sr, imag: si }, pair.params);
            
            // Check for NaN or Infinity
            if (!isFinite(result.real) || !isFinite(result.imag)) {
                return { real: NaN, imag: NaN, divergent: true };
            }
            
            // Check for very large values (near poles)
            const magnitude = Math.sqrt(result.real * result.real + result.imag * result.imag);
            if (magnitude > 1e6) {
                return { real: NaN, imag: NaN, divergent: true };
            }
            
            return { real: result.real, imag: result.imag, divergent: false };
        }

        function evaluateTimeFunction(t) {
            const pair = laplacePairs[currentFunction];
            return pair.timeFunc(t, pair.params);
        }

        function init() {
            sceneSPlane = new THREE.Scene();
            sceneSPlane.background = new THREE.Color(0x191919);
            
            sceneLaplace = new THREE.Scene();
            sceneLaplace.background = new THREE.Color(0x191919);

            setupSPlaneViewport();
            setupLaplaceViewport();

            createSPlane();
            updatePoleMarkers();
            createLaplaceDomain();

            setupEventListeners();

            updateVisualization();
            renderEquation();

            animate();
        }

        function setupSPlaneViewport() {
            const container = document.getElementById('s-plane-viewport');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 10;
            
            cameraSPlane = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                1000
            );
            
            cameraSPlane.position.set(0, 0, 10);
            cameraSPlane.lookAt(0, 0, 0);
            
            rendererSPlane = new THREE.WebGLRenderer({ antialias: true });
            rendererSPlane.setSize(container.clientWidth, container.clientHeight);
            rendererSPlane.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(rendererSPlane.domElement);
        }

        function setupLaplaceViewport() {
            const container = document.getElementById('laplace-viewport');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 15;
            
            cameraLaplace = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                1000
            );
            
            rendererLaplace = new THREE.WebGLRenderer({ antialias: true });
            rendererLaplace.setSize(container.clientWidth, container.clientHeight);
            rendererLaplace.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(rendererLaplace.domElement);
            
            updateCameraPosition();
        }

        function createTextSprite(text, scale = 2) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            context.fillStyle = 'white';
            context.font = 'Bold 64px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                depthTest: true,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(scale, scale / 2, 1);
            sprite.renderOrder = -1;
            
            return sprite;
        }

        // ── s-plane dynamic grid state ──
        const sPlaneGrid = {
            gridLines: [],       // {line, axis:'h'|'v', coord} – reusable Line objects
            tickLines: [],       // reusable tick Line objects
            tickLabels: [],      // reusable Sprite objects
            axisLabels: [],      // σ / iω sprites
            axisLines: [],       // the two axis Line objects
            axisArrows: [],      // the two ArrowHelper objects
            originLabel: null,
            poleMarkers: [],     // red X meshes, rebuilt on function change
            lastZoom: NaN        // track zoom to avoid rebuilding geometry on pure pan
        };

        function createSPlane() {
            // ── axes (infinite lines + arrows + labels) ──
            const axisMat = new THREE.LineBasicMaterial({ color: 0xffffff });

            // Real axis line (will be repositioned in updateSPlaneGrid)
            const realGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-100, 0, 0.01), new THREE.Vector3(100, 0, 0.01)
            ]);
            const realLine = new THREE.Line(realGeo, axisMat);
            sceneSPlane.add(realLine);
            sPlaneGrid.axisLines.push(realLine);

            // Imaginary axis line
            const imagGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -100, 0.01), new THREE.Vector3(0, 100, 0.01)
            ]);
            const imagLine = new THREE.Line(imagGeo, axisMat);
            sceneSPlane.add(imagLine);
            sPlaneGrid.axisLines.push(imagLine);

            // Arrows – created once, repositioned each frame
            const realArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0.01), 0.4, 0xffffff, 0.2, 0.15);
            sceneSPlane.add(realArrow);
            sPlaneGrid.axisArrows.push(realArrow);

            const imagArrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0.01), 0.4, 0xffffff, 0.2, 0.15);
            sceneSPlane.add(imagArrow);
            sPlaneGrid.axisArrows.push(imagArrow);

            // Axis label sprites
            const sigmaLabel = createTextSprite('σ', 0.8);
            sceneSPlane.add(sigmaLabel);
            sPlaneGrid.axisLabels.push(sigmaLabel);

            const omegaLabel = createTextSprite('iω', 0.8);
            sceneSPlane.add(omegaLabel);
            sPlaneGrid.axisLabels.push(omegaLabel);

            // Origin label - removed per user request
            // sPlaneGrid.originLabel = createTextSprite('0', 0.5);
            // sceneSPlane.add(sPlaneGrid.originLabel);

            // ── draggable dot ──
            // Use radius 1 geometry; actual visible size is driven by mesh.scale in updateSPlaneGrid
            const dotGeom = new THREE.SphereGeometry(1, 16, 16);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            draggableDot = new THREE.Mesh(dotGeom, dotMat);
            draggableDot.position.set(sReal, sImag, 0.02);
            sceneSPlane.add(draggableDot);

            // Initial grid + poles
            updateSPlaneGrid();
            updatePoleMarkers();
        }

        // Returns the visible world-space bounds given current pan & zoom
        function getVisibleBounds() {
            const container = document.getElementById('s-plane-viewport');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 10;
            const halfW = (frustumSize * aspect / 2) / controlsSPlane.zoom;
            const halfH = (frustumSize / 2) / controlsSPlane.zoom;
            return {
                left:   controlsSPlane.panX - halfW,
                right:  controlsSPlane.panX + halfW,
                bottom: controlsSPlane.panY - halfH,
                top:    controlsSPlane.panY + halfH
            };
        }

        function updateSPlaneGrid() {
            const b = getVisibleBounds();
            const zoom = controlsSPlane.zoom;
            const zoomChanged = !isFinite(sPlaneGrid.lastZoom) || Math.abs(zoom - sPlaneGrid.lastZoom) > 1e-6;

            // ── pick a nice step that keeps grid density reasonable ──
            const rawSpan = Math.max(b.right - b.left, b.top - b.bottom);
            let step = Math.pow(10, Math.floor(Math.log10(rawSpan / 8)));
            if (rawSpan / step > 16) step *= 2;
            if (rawSpan / step < 6)  step /= 2;
            if (step < 0.01) step = 0.01;

            // ── grid lines ──
            const minI = Math.floor(b.left  / step);
            const maxI = Math.ceil(b.right / step);
            const minJ = Math.floor(b.bottom / step);
            const maxJ = Math.ceil(b.top / step);
            const needed = (maxI - minI + 1) + (maxJ - minJ + 1);

            const gridMat = new THREE.LineBasicMaterial({ color: 0x444444 });
            while (sPlaneGrid.gridLines.length < needed) {
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(1,0,0)]);
                const l = new THREE.Line(g, gridMat);
                l.visible = false;
                sceneSPlane.add(l);
                sPlaneGrid.gridLines.push(l);
            }
            let gi = 0;
            for (let i = minI; i <= maxI; i++) {
                const x = i * step;
                const l = sPlaneGrid.gridLines[gi++];
                l.geometry.setFromPoints([new THREE.Vector3(x, b.bottom, 0), new THREE.Vector3(x, b.top, 0)]);
                l.geometry.computeBoundingSphere();
                l.visible = true;
            }
            for (let j = minJ; j <= maxJ; j++) {
                const y = j * step;
                const l = sPlaneGrid.gridLines[gi++];
                l.geometry.setFromPoints([new THREE.Vector3(b.left, y, 0), new THREE.Vector3(b.right, y, 0)]);
                l.geometry.computeBoundingSphere();
                l.visible = true;
            }
            for (; gi < sPlaneGrid.gridLines.length; gi++) sPlaneGrid.gridLines[gi].visible = false;

            // ── arrows: always reposition, but only rebuild geometry if zoom changed ──
            const arrowLen    = 0.4  / zoom;
            const arrowHead   = 0.2  / zoom;
            const arrowRadius = 0.08 / zoom;

            [sPlaneGrid.axisArrows[0], sPlaneGrid.axisArrows[1]].forEach((arrow, idx) => {
                if (idx === 0) {
                    arrow.position.set(b.right - arrowLen, 0, 0.01);
                } else {
                    arrow.position.set(0, b.top - arrowLen, 0.01);
                }
                
                if (zoomChanged) {
                    const cone = arrow.children[1];
                    cone.geometry.dispose();
                    cone.geometry = new THREE.ConeGeometry(arrowRadius, arrowHead, 8);
                    cone.position.y = arrowLen - arrowHead / 2;
                    
                    const shaft = arrow.children[0];
                    shaft.geometry.dispose();
                    shaft.geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, arrowLen - arrowHead, 0)
                    ]);
                    shaft.geometry.computeBoundingSphere();
                }
            });

            // ── axis labels, origin label, dot: only update if zoom changed ──
            if (zoomChanged) {
                const axisLabelScale = 0.8 / zoom;
                sPlaneGrid.axisLabels[0].position.set(b.right + 0.05 / zoom, 0, 0.01);
                sPlaneGrid.axisLabels[0].scale.set(axisLabelScale, axisLabelScale / 2, 1);
                sPlaneGrid.axisLabels[1].position.set(0, b.top + 0.05 / zoom, 0.01);
                sPlaneGrid.axisLabels[1].scale.set(axisLabelScale, axisLabelScale / 2, 1);

                // Origin label removed
                // const originLabelScale = Math.max(0.25, 0.5 / zoom);
                // sPlaneGrid.originLabel.position.set(-0.4 / zoom, -0.4 / zoom, 0.01);
                // sPlaneGrid.originLabel.scale.set(originLabelScale, originLabelScale / 2, 1);

                const dotRadius = 0.12 / zoom;
                if (draggableDot) draggableDot.scale.setScalar(dotRadius);
            } else {
                // On pure pan, just update label positions (not scale)
                sPlaneGrid.axisLabels[0].position.set(b.right + 0.05 / zoom, 0, 0.01);
                sPlaneGrid.axisLabels[1].position.set(0, b.top + 0.05 / zoom, 0.01);
                // sPlaneGrid.originLabel.position.set(-0.4 / zoom, -0.4 / zoom, 0.01);
            }

            // ── tick marks + numeric labels ──
            const tickSize = 0.12 / zoom;
            const tickMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const labelScale = Math.max(0.25, 0.5 / zoom);

            const ticks = [];
            for (let i = minI; i <= maxI; i++) {
                const x = i * step;
                if (Math.abs(x) < 1e-9) continue;
                ticks.push({ x, y: 0, label: formatNum(x), axis: 'real' });
            }
            for (let j = minJ; j <= maxJ; j++) {
                const y = j * step;
                if (Math.abs(y) < 1e-9) continue;
                ticks.push({ x: 0, y, label: formatNum(y) + 'i', axis: 'imag' });
            }

            while (sPlaneGrid.tickLines.length < ticks.length) {
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(1,0,0)]);
                const l = new THREE.Line(g, tickMat);
                l.visible = false;
                sceneSPlane.add(l);
                sPlaneGrid.tickLines.push(l);
            }
            while (sPlaneGrid.tickLabels.length < ticks.length) {
                const s = createTextSprite('0', 0.5);
                s.visible = false;
                sceneSPlane.add(s);
                sPlaneGrid.tickLabels.push(s);
            }

            for (let ti = 0; ti < ticks.length; ti++) {
                const t = ticks[ti];
                const tl = sPlaneGrid.tickLines[ti];
                const ll = sPlaneGrid.tickLabels[ti];

                if (t.axis === 'real') {
                    tl.geometry.setFromPoints([
                        new THREE.Vector3(t.x, -tickSize, 0.01),
                        new THREE.Vector3(t.x,  tickSize, 0.01)
                    ]);
                    ll.position.set(t.x, -0.35 / zoom, 0.01);
                } else {
                    tl.geometry.setFromPoints([
                        new THREE.Vector3(-tickSize, t.y, 0.01),
                        new THREE.Vector3( tickSize, t.y, 0.01)
                    ]);
                    ll.position.set(-0.55 / zoom, t.y, 0.01);
                }
                tl.geometry.computeBoundingSphere();
                tl.visible = true;
                ll.visible = true;
                ll.scale.set(labelScale, labelScale / 2, 1);
                updateSpriteText(ll, t.label);
            }
            for (let ti = ticks.length; ti < sPlaneGrid.tickLines.length; ti++) {
                sPlaneGrid.tickLines[ti].visible = false;
                sPlaneGrid.tickLabels[ti].visible = false;
            }

            // ── rebuild pole X markers only if zoom changed ──
            if (zoomChanged) {
                rebuildPoleXGeometry();
                sPlaneGrid.lastZoom = zoom;
            }
        }

        function formatNum(v) {
            if (Math.abs(v - Math.round(v)) < 1e-9) return Math.round(v).toString();
            // show one decimal if it's a half-step, else two
            const s1 = v.toFixed(1);
            if (Math.abs(parseFloat(s1) - v) < 1e-9) return s1;
            return v.toFixed(2);
        }

        function updateSpriteText(sprite, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            ctx.fillStyle = 'white';
            ctx.font = 'Bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);
            sprite.material.map.image = canvas;
            sprite.material.map.needsUpdate = true;
        }

        // ── Pole markers ──
        function getPoles() {
            const pair = laplacePairs[currentFunction];
            return pair.poles ? pair.poles(pair.params) : [];
        }

        function createPoleX(pos) {
            // size scales inversely with zoom so the X stays a constant screen size
            const size = 0.08 / controlsSPlane.zoom;
            const mat = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const g1 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(pos.real - size, pos.imag - size, 0.03),
                new THREE.Vector3(pos.real + size, pos.imag + size, 0.03)
            ]);
            const g2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(pos.real + size, pos.imag - size, 0.03),
                new THREE.Vector3(pos.real - size, pos.imag + size, 0.03)
            ]);
            g1.computeBoundingSphere();
            g2.computeBoundingSphere();
            const l1 = new THREE.Line(g1, mat);
            const l2 = new THREE.Line(g2, mat);
            const group = new THREE.Group();
            group.add(l1);
            group.add(l2);
            group.userData.isPoleMarker = true;
            group.userData.polePos = pos;   // store so we can rebuild geometry later
            return group;
        }

        function updatePoleMarkers() {
            sPlaneGrid.poleMarkers.forEach(m => sceneSPlane.remove(m));
            sPlaneGrid.poleMarkers = [];
            const poles = getPoles();
            poles.forEach(p => {
                const x = createPoleX(p);
                sceneSPlane.add(x);
                sPlaneGrid.poleMarkers.push(x);
            });
        }

        // Called every grid update so pole-X size tracks zoom smoothly
        function rebuildPoleXGeometry() {
            const size = 0.08 / controlsSPlane.zoom;
            sPlaneGrid.poleMarkers.forEach(group => {
                const pos = group.userData.polePos;
                const l1 = group.children[0];
                const l2 = group.children[1];
                l1.geometry.setFromPoints([
                    new THREE.Vector3(pos.real - size, pos.imag - size, 0.03),
                    new THREE.Vector3(pos.real + size, pos.imag + size, 0.03)
                ]);
                l1.geometry.computeBoundingSphere();
                l2.geometry.setFromPoints([
                    new THREE.Vector3(pos.real + size, pos.imag - size, 0.03),
                    new THREE.Vector3(pos.real - size, pos.imag + size, 0.03)
                ]);
                l2.geometry.computeBoundingSphere();
            });
        }

        function createLaplaceDomain() {
            const size = 10;
            const divisions = 10;
            
            // Complex plane grid at t=0
            const gridHelper1 = new THREE.GridHelper(size, divisions, 0x444444, 0x444444);
            gridHelper1.rotation.x = Math.PI / 2;
            gridHelper1.position.z = 0;
            sceneLaplace.add(gridHelper1);
            
            const planeGeom1 = new THREE.PlaneGeometry(10, 10);
            const planeMat1 = new THREE.MeshBasicMaterial({ 
                color: 0x1a3a4a,
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const plane1 = new THREE.Mesh(planeGeom1, planeMat1);
            plane1.position.z = 0;
            plane1.renderOrder = -1;
            sceneLaplace.add(plane1);
            
            // t-Re plane (horizontal, sits on Im = 0)
            const gridHelper2 = new THREE.GridHelper(size, divisions, 0x444444, 0x444444);
            gridHelper2.rotation.y = Math.PI / 2;
            gridHelper2.position.y = 0;
            sceneLaplace.add(gridHelper2);
            
            const planeGeom2 = new THREE.PlaneGeometry(10, 10);
            const planeMat2 = new THREE.MeshBasicMaterial({ 
                color: 0x3a2a1a,
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const plane2 = new THREE.Mesh(planeGeom2, planeMat2);
            plane2.rotation.x = Math.PI / 2;
            plane2.position.y = 0;
            plane2.renderOrder = -1;
            sceneLaplace.add(plane2);
            
            createAxes();
        }

        function createAxes() {
            const arrowLength = 5;
            const arrowColor = 0xffffff;
            
            // t axis (time) - starting from origin, pointing in positive z direction
            const tArrow = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, 0),
                arrowLength,
                arrowColor,
                0.3,
                0.2
            );
            sceneLaplace.add(tArrow);
            
            const tLabel = createTextSprite('t', 2);
            tLabel.position.set(0, 0, arrowLength + 0.8);
            sceneLaplace.add(tLabel);
            
            // Real axis - at t=0
            const realArrow = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 0, 0),
                arrowLength,
                arrowColor,
                0.3,
                0.2
            );
            sceneLaplace.add(realArrow);
            
            const realLabel = createTextSprite('Re', 2);
            realLabel.position.set(arrowLength + 0.8, 0, 0);
            sceneLaplace.add(realLabel);
            
            // Imaginary axis - at t=0
            const imagArrow = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 0),
                arrowLength,
                arrowColor,
                0.3,
                0.2
            );
            sceneLaplace.add(imagArrow);
            
            const imagLabel = createTextSprite('Im', 2);
            imagLabel.position.set(0, arrowLength + 0.8, 0);
            sceneLaplace.add(imagLabel);
        }

        function updateCameraPosition() {
            const radius = 30;
            const x = radius * Math.sin(controlsLaplace.phi) * Math.cos(controlsLaplace.theta);
            const y = radius * Math.cos(controlsLaplace.phi);
            const z = radius * Math.sin(controlsLaplace.phi) * Math.sin(controlsLaplace.theta);
            
            cameraLaplace.position.set(x, y, z);
            cameraLaplace.lookAt(0, 0, 0);
        }

        function updateCameraZoom() {
            cameraLaplace.zoom = controlsLaplace.zoom;
            cameraLaplace.updateProjectionMatrix();
        }

        function updateSPlaneCameraPosition() {
            cameraSPlane.position.x = controlsSPlane.panX;
            cameraSPlane.position.y = controlsSPlane.panY;
            cameraSPlane.zoom = controlsSPlane.zoom;
            cameraSPlane.updateProjectionMatrix();
            updateSPlaneGrid();
        }

        function renderEquation() {
            const equationElement = document.getElementById('equation');
            const mobileEquationElement = document.getElementById('mobile-equation');

            const pair = laplacePairs[currentFunction];
            
            // Format s value
            const sigmaStr = Math.abs(sReal) < 1e-12 ? '0' : sReal.toFixed(2);
            const omegaStr = Math.abs(sImag) < 1e-12 ? '0' : Math.abs(sImag).toFixed(2);
            const omegaSign = sImag >= 0 ? '+' : '-';
            const sValueStr = `\\textcolor{#FFA500}{${sigmaStr}${omegaSign}${omegaStr}i}`;
            
            // Use lastComputedResult which is set by updateVisualization –
            // this is the single source of truth that covers both pole-proximity
            // and analytic-validity checks, so vector and equation stay in sync.
            let fsValueStr;
            
            if (lastComputedResult.divergent) {
                fsValueStr = '\\textcolor{#FF0000}{\\widetilde{\\infty}}';
            } else {
                const realStr = Math.abs(lastComputedResult.real) < 1e-12 ? '0' : lastComputedResult.real.toFixed(2);
                const imagStr = Math.abs(lastComputedResult.imag) < 1e-12 ? '0' : Math.abs(lastComputedResult.imag).toFixed(2);
                const imagSign = lastComputedResult.imag >= 0 ? '+' : '-';
                fsValueStr = `\\textcolor{#00FF00}{${realStr}${imagSign}${imagStr}i}`;
            }
            
            // Build closed-form with s plugged in
            const s = `(${sValueStr})`;
            let closedFormula = '';
            
            switch(currentFunction) {
                case 'exp':
                    closedFormula = `\\frac{1}{${s} + a}`;
                    break;
                case 'constant':
                    closedFormula = `\\frac{1}{${s}}`;
                    break;
                case 't':
                    closedFormula = `\\frac{1}{${s}^2}`;
                    break;
                case 't2':
                    closedFormula = `\\frac{2}{${s}^3}`;
                    break;
                case 'sin':
                    closedFormula = `\\frac{\\omega}{${s}^2 + \\omega^2}`;
                    break;
                case 'cos':
                    closedFormula = `\\frac{${s}}{${s}^2 + \\omega^2}`;
                    break;
                case 'exp_sin':
                    closedFormula = `\\frac{\\omega}{(${s} + a)^2 + \\omega^2}`;
                    break;
                case 'exp_cos':
                    closedFormula = `\\frac{${s} + a}{(${s} + a)^2 + \\omega^2}`;
                    break;
            }
            
            const latex = `\\int_{0}^{\\infty} ${pair.name} \\, e^{-(${sValueStr})t} dt = ${closedFormula} = ${fsValueStr}`;
            
            try {
                if (equationElement && window.katex) {
                    katex.render(latex, equationElement, { throwOnError: false, displayMode: false });
                }
                if (mobileEquationElement && window.katex) {
                    katex.render(latex, mobileEquationElement, { throwOnError: false, displayMode: false });
                }
            } catch (e) {
                console.error("KaTeX render error:", e);
            }

            if (!window.katex) {
                setTimeout(renderEquation, 100);
            }
        }

        // Returns the minimum distance from (sReal,sImag) to any pole of the current function
        function distToPoles() {
            const poles = getPoles();
            let minDist = Infinity;
            poles.forEach(p => {
                const d = Math.sqrt((sReal - p.real)**2 + (sImag - p.imag)**2);
                if (d < minDist) minDist = d;
            });
            return minDist;
        }

        // Snap sReal/sImag onto the nearest pole if within a zoom-scaled radius.
        // Returns true if a snap happened.
        function trySnapToPole() {
            const poles = getPoles();
            // Base snap radius in world units; dividing by zoom means when zoomed in
            // the snap zone covers more world-space → more leeway for the user.
            const snapRadius = 0.08 / controlsSPlane.zoom;
            let bestDist = Infinity;
            let bestPole = null;
            poles.forEach(p => {
                const d = Math.sqrt((sReal - p.real)**2 + (sImag - p.imag)**2);
                if (d < bestDist) { bestDist = d; bestPole = p; }
            });
            if (bestPole && bestDist < snapRadius) {
                sReal = bestPole.real;
                sImag = bestPole.imag;
                return true;
            }
            return false;
        }

        function updateVisualization() {
            sceneLaplace.children = sceneLaplace.children.filter(child => !child.userData.isDynamic);

            // ── snap to pole if close enough (zoom-aware) ──
            trySnapToPole();

            // ── decide: are we on a pole? ──
            // Use the same radius as the snap so the two are in lockstep:
            // once the snap fires the dot lands exactly on the pole, which is
            // trivially < this threshold.  Outside the snap radius the dot is
            // always farther away than this threshold so it never falsely triggers.
            const POLE_THRESHOLD = 0.08 / controlsSPlane.zoom;
            const nearPole = distToPoles() < POLE_THRESHOLD;

            // ── 3D curve: always drawn from the windowed numerical integration ──
            const tSamples = 3000;
            const curvePoints = [];
            const tRange = tMax - tMin;

            for (let i = 0; i < tSamples; i++) {
                const t = tMin + (i / tSamples) * tRange;
                const ft = evaluateTimeFunction(t);
                const expFactor = Math.exp(-sReal * t);
                const angle = -sImag * t;
                const integrandReal = ft * expFactor * Math.cos(angle);
                const integrandImag = ft * expFactor * Math.sin(angle);

                if (isFinite(integrandReal) && isFinite(integrandImag)) {
                    curvePoints.push(new THREE.Vector3(integrandReal, integrandImag, t));
                }
            }

            if (curvePoints.length > 1) {
                const curveGeom = new THREE.BufferGeometry().setFromPoints(curvePoints);
                const curveMat = new THREE.LineBasicMaterial({ color: 0xff6b6b, linewidth: 2 });
                const curveLine = new THREE.Line(curveGeom, curveMat);
                curveLine.userData.isDynamic = true;
                sceneLaplace.add(curveLine);
            }

            // ── analytic result (infinite-range closed-form) ──
            const analyticResult = evaluateTransform(sReal, sImag);
            const analyticValid = !analyticResult.divergent &&
                                  isFinite(analyticResult.real) && isFinite(analyticResult.imag) &&
                                  Math.abs(analyticResult.real) < 1e6 && Math.abs(analyticResult.imag) < 1e6;

            if (nearPole || !analyticValid) {
                // ── near-pole / divergent state ──
                lastComputedResult = { real: NaN, imag: NaN, divergent: true };
                if (draggableDot) draggableDot.material.color.setHex(0xff0000);
                // NO vector or cone drawn
            } else {
                // ── normal state ──
                lastComputedResult = { real: analyticResult.real, imag: analyticResult.imag, divergent: false };
                if (draggableDot) draggableDot.material.color.setHex(0xffa500);

                const finalReal = analyticResult.real;
                const finalImag = analyticResult.imag;

                // vector line
                const vectorGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(finalReal, finalImag, 0)
                ]);
                const vectorMat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
                const vectorLine = new THREE.Line(vectorGeom, vectorMat);
                vectorLine.userData.isDynamic = true;
                sceneLaplace.add(vectorLine);

                // cone arrowhead
                const magnitude = Math.sqrt(finalReal * finalReal + finalImag * finalImag);
                const coneHeight = Math.max(0.1, Math.min(0.4, magnitude * 0.15));
                const coneRadius = coneHeight * 0.5;
                const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                const coneMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const cone = new THREE.Mesh(coneGeom, coneMat);

                if (magnitude > 0.001) {
                    const direction = new THREE.Vector3(finalReal, finalImag, 0).normalize();
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                    cone.setRotationFromQuaternion(quaternion);
                    cone.position.set(finalReal, finalImag, 0);
                    cone.position.add(direction.multiplyScalar(-coneHeight / 2));
                } else {
                    cone.position.set(finalReal, finalImag, 0);
                }
                cone.userData.isDynamic = true;
                sceneLaplace.add(cone);
            }

            // update dot world position
            if (draggableDot) draggableDot.position.set(sReal, sImag, 0.02);

            renderEquation();
        }

        function getPinchDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function isPointInElement(x, y, element) {
            const rect = element.getBoundingClientRect();
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }

        function setupEventListeners() {
            const functionSelect = document.getElementById('function-select');
            const functionSelectMobile = document.getElementById('function-select-mobile');
            const hudToggle = document.getElementById('hud-toggle');
            const hudToggleMobile = document.getElementById('hud-toggle-mobile');
            const hud = document.getElementById('hud');
            const mobileFunctionPanel = document.getElementById('mobile-function-panel');

            // Desktop HUD toggle
            if (hudToggle && hud) {
                hudToggle.addEventListener('click', () => {
                    hud.classList.toggle('hidden');
                });
            }

            // Mobile HUD toggle
            if (hudToggleMobile && mobileFunctionPanel) {
                hudToggleMobile.addEventListener('click', () => {
                    mobileFunctionPanel.classList.toggle('hidden');
                });
            }

            // Function select handler
            const handleFunctionSelect = (e) => {
                currentFunction = e.target.value;
                
                if (functionSelect) functionSelect.value = currentFunction;
                if (functionSelectMobile) functionSelectMobile.value = currentFunction;
                
                updatePoleMarkers();
                renderEquation();
                updateVisualization();
            };

            if (functionSelect) {
                functionSelect.addEventListener('change', handleFunctionSelect);
            }
            if (functionSelectMobile) {
                functionSelectMobile.addEventListener('change', handleFunctionSelect);
            }

            // Setup s-plane controls (for dragging and zooming)
            setupSPlaneControls();

            // Setup Laplace viewport controls (for rotation)
            setupLaplaceControls(rendererLaplace.domElement);

            // Window resize
            window.addEventListener('resize', () => {
                resizeViewport('s-plane');
                resizeViewport('laplace');
            });

            // Prevent body touch scroll
            document.body.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        function setupSPlaneControls() {
            const canvas = rendererSPlane.domElement;
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function getMousePosition(e, rect) {
                // Handle both mouse events (e.clientX) and touch events (e.touches[0].clientX)
                const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return {
                    x: (x / rect.width) * 2 - 1,
                    y: -(y / rect.height) * 2 + 1
                };
            }

            function updateDotFromMouse(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();
                const mousePos = getMousePosition({ clientX, clientY }, rect);
                
                mouse.x = mousePos.x;
                mouse.y = mousePos.y;

                raycaster.setFromCamera(mouse, cameraSPlane);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);

                sReal = intersectPoint.x;
                sImag = intersectPoint.y;

                updateVisualization();
            }

            const getPointerPosition = (e) => {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            };

            const onPointerMove = (e) => {
                if (controlsSPlane.isPinching && e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const currentDistance = getPinchDistance(e.touches[0], e.touches[1]);
                    const ratio = currentDistance / controlsSPlane.previousPinchDistance;
                    
                    controlsSPlane.zoom = Math.max(0.3, Math.min(10, 
                        controlsSPlane.zoom * ratio));
                    updateSPlaneCameraPosition();
                    
                    controlsSPlane.previousPinchDistance = currentDistance;

                } else if (isDraggingDot) {
                    e.preventDefault();
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    updateDotFromMouse(clientX, clientY);
                } else if (controlsSPlane.isDragging) {
                    e.preventDefault();
                    const pos = getPointerPosition(e);
                    const deltaX = pos.x - controlsSPlane.previousMousePosition.x;
                    const deltaY = pos.y - controlsSPlane.previousMousePosition.y;

                    const movementScale = 0.01 / controlsSPlane.zoom;
                    controlsSPlane.panX -= deltaX * movementScale;
                    controlsSPlane.panY += deltaY * movementScale;

                    controlsSPlane.previousMousePosition = pos;
                    updateSPlaneCameraPosition();
                }
            };

            const onPointerUp = () => {
                isDraggingDot = false;
                controlsSPlane.isDragging = false;
                controlsSPlane.isPinching = false;
                
                window.removeEventListener('mousemove', onPointerMove);
                window.removeEventListener('mouseup', onPointerUp);
                window.removeEventListener('touchmove', onPointerMove);
                window.removeEventListener('touchend', onPointerUp);
                window.removeEventListener('touchcancel', onPointerUp);
            };

            const onPointerDown = (e) => {
                if (e.type === 'touchstart' && !isPointInElement(e.touches[0].clientX, e.touches[0].clientY, canvas)) {
                    return;
                }
                
                e.preventDefault();
                
                if (e.touches && e.touches.length === 2) {
                    if (isPointInElement(e.touches[0].clientX, e.touches[0].clientY, canvas) &&
                        isPointInElement(e.touches[1].clientX, e.touches[1].clientY, canvas)) {
                        
                        isDraggingDot = false;
                        controlsSPlane.isDragging = false;
                        controlsSPlane.isPinching = true;
                        controlsSPlane.previousPinchDistance = getPinchDistance(e.touches[0], e.touches[1]);
                    }
                } else {
                    const rect = canvas.getBoundingClientRect();
                    const mousePos = getMousePosition(e, rect);
                    
                    mouse.x = mousePos.x;
                    mouse.y = mousePos.y;

                    raycaster.setFromCamera(mouse, cameraSPlane);
                    
                    // Hit zone scales with the dot's visible world-space size (0.12/zoom).
                    // Touch gets a 3× multiplier so it's easy to grab on mobile.
                    const isTouchDevice = e.type === 'touchstart';
                    const hitThreshold = (isTouchDevice ? 0.36 : 0.12) / controlsSPlane.zoom;
                    
                    // Check distance to dot in world space
                    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectPoint);
                    
                    const distToDot = Math.sqrt(
                        (intersectPoint.x - sReal) * (intersectPoint.x - sReal) +
                        (intersectPoint.y - sImag) * (intersectPoint.y - sImag)
                    );
                    
                    if (distToDot < hitThreshold) {
                        isDraggingDot = true;
                        controlsSPlane.isPinching = false;
                        controlsSPlane.isDragging = false;
                    } else {
                        isDraggingDot = false;
                        controlsSPlane.isPinching = false;
                        controlsSPlane.isDragging = true;
                        controlsSPlane.previousMousePosition = getPointerPosition(e);
                    }
                }

                window.addEventListener('mousemove', onPointerMove);
                window.addEventListener('mouseup', onPointerUp);
                window.addEventListener('touchmove', onPointerMove, { passive: false });
                window.addEventListener('touchend', onPointerUp);
                window.addEventListener('touchcancel', onPointerUp);
            };

            const onWheel = (e) => {
                e.preventDefault();
                const zoomFactor = Math.exp(-e.deltaY * 0.001);
                controlsSPlane.zoom = Math.max(0.3, Math.min(10, 
                    controlsSPlane.zoom * zoomFactor));
                updateSPlaneCameraPosition();
            };

            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('touchstart', onPointerDown, { passive: false });
            canvas.addEventListener('wheel', onWheel, { passive: false });
        }

        function setupLaplaceControls(canvas) {
            const getPointerPosition = (e) => {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            };

            const onPointerMove = (e) => {
                if (controlsLaplace.isPinching && e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const currentDistance = getPinchDistance(e.touches[0], e.touches[1]);
                    const delta = currentDistance - controlsLaplace.previousPinchDistance;
                    
                    controlsLaplace.zoom = Math.max(0.5, Math.min(3, 
                        controlsLaplace.zoom + delta * 0.005));
                    updateCameraZoom();
                    
                    controlsLaplace.previousPinchDistance = currentDistance;

                } else if (controlsLaplace.isDragging) {
                    e.preventDefault();
                    const pos = getPointerPosition(e);
                    const deltaX = pos.x - controlsLaplace.previousMousePosition.x;
                    const deltaY = pos.y - controlsLaplace.previousMousePosition.y;

                    controlsLaplace.theta -= deltaX * 0.005;
                    controlsLaplace.phi = Math.max(0.001, Math.min(Math.PI - 0.001, 
                        controlsLaplace.phi + deltaY * 0.005));

                    controlsLaplace.previousMousePosition = pos;
                    updateCameraPosition();
                }
            };

            const onPointerUp = () => {
                controlsLaplace.isDragging = false;
                controlsLaplace.isPinching = false;
                
                window.removeEventListener('mousemove', onPointerMove);
                window.removeEventListener('mouseup', onPointerUp);
                window.removeEventListener('touchmove', onPointerMove);
                window.removeEventListener('touchend', onPointerUp);
                window.removeEventListener('touchcancel', onPointerUp);
            };

            const onPointerDown = (e) => {
                if (e.type === 'touchstart' && !isPointInElement(e.touches[0].clientX, e.touches[0].clientY, canvas)) {
                    return;
                }
                
                e.preventDefault();
                
                if (e.touches && e.touches.length === 2) {
                    if (isPointInElement(e.touches[0].clientX, e.touches[0].clientY, canvas) &&
                        isPointInElement(e.touches[1].clientX, e.touches[1].clientY, canvas)) {
                        
                        controlsLaplace.isDragging = false;
                        controlsLaplace.isPinching = true;
                        controlsLaplace.previousPinchDistance = getPinchDistance(e.touches[0], e.touches[1]);
                    }
                } else {
                    controlsLaplace.isPinching = false;
                    controlsLaplace.isDragging = true;
                    controlsLaplace.previousMousePosition = getPointerPosition(e);
                }

                window.addEventListener('mousemove', onPointerMove);
                window.addEventListener('mouseup', onPointerUp);
                window.addEventListener('touchmove', onPointerMove, { passive: false });
                window.addEventListener('touchend', onPointerUp);
                window.addEventListener('touchcancel', onPointerUp);
            };

            const onWheel = (e) => {
                e.preventDefault();
                controlsLaplace.zoom = Math.max(0.5, Math.min(3, 
                    controlsLaplace.zoom - e.deltaY * 0.001));
                updateCameraZoom();
            };

            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('touchstart', onPointerDown, { passive: false });
            canvas.addEventListener('wheel', onWheel, { passive: false });
        }

        function resizeViewport(domain) {
            const container = document.getElementById(`${domain}-viewport`);
            if (!container) return;
            
            const camera = domain === 's-plane' ? cameraSPlane : cameraLaplace;
            const renderer = domain === 's-plane' ? rendererSPlane : rendererLaplace;

            if (!camera || !renderer) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            if (width === 0 || height === 0) return;
            
            const aspect = width / height;
            const frustumSize = domain === 's-plane' ? 10 : 15;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            if (domain === 's-plane') updateSPlaneGrid();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (rendererSPlane && sceneSPlane && cameraSPlane) {
                rendererSPlane.render(sceneSPlane, cameraSPlane);
            }
            if (rendererLaplace && sceneLaplace && cameraLaplace) {
                rendererLaplace.render(sceneLaplace, cameraLaplace);
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
